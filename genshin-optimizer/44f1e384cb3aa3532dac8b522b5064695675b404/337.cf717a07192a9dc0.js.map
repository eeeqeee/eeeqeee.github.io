{"version":3,"file":"337.cf717a07192a9dc0.js","mappings":"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,SACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,UACA,YACA,QACA,WACA,QACA,WACA,YACA,OACA,UACA,SACA,UACA,SACA,SACA,QACA,UACA,SACA,WAGWC,EAAe,CAC1B,gBACA,cACA,kBACA,kBClFK,MCGMC,EAAqB,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,wBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,kBACA,sBACA,mBAIWC,EAAwB,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIWC,EAAuB,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,mBACA,cACA,4BACA,uBACA,aACA,eACA,cACA,yBACA,WACA,mBACA,kBACA,eAIWC,EAAmB,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,eACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,gBAIWC,EAAwB,CACnC,mBACA,0BACA,kBACA,cACA,aACA,sBACA,kBACA,gBACA,cACA,qBACA,eACA,gBACA,6BACA,aACA,YACA,eACA,eACA,oBACA,iBACA,iBACA,gBACA,uBACA,eACA,aACA,aACA,gCACA,0BACA,eACA,oBACA,eClKWC,EAAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAiDrDN,EAAe,CAC1B,gBACA,cACA,kBACA,kBCtDK,SAASO,EAASC,EAAkBC,EAAmBC,EAAu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","sources":["webpack:///webpack/runtime/chunk loaded","webpack:///webpack/runtime/startup chunk dependencies","webpack:///./src/app/Util/Util.ts","webpack:///./src/app/Formula/utils.ts","webpack:///./src/app/Formula/internal.ts","webpack:///./src/app/Formula/optimization.ts","webpack:///../../libs/consts/src/character.ts","webpack:///../../libs/consts/src/artifact.ts","webpack:///../../libs/consts/src/weapon.ts","webpack:///./src/app/Types/consts.ts","webpack:///./src/app/PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","webpack:///./src/app/PageCharacter/CharacterDisplay/Tabs/TabOptimize/BNBSplitWorker.ts","webpack:///./src/app/PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","webpack:///./src/app/PageCharacter/CharacterDisplay/Tabs/TabOptimize/DefaultSplitWorker.ts","webpack:///./src/app/PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","webpack:///webpack/bootstrap","webpack:///webpack/runtime/ensure chunk","webpack:///webpack/runtime/get javascript chunk filename","webpack:///webpack/runtime/get mini-css chunk filename","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///webpack/runtime/publicPath","webpack:///webpack/runtime/importScripts chunk loading","webpack:///webpack/startup"],"sourcesContent":["var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","var next = __webpack_require__.x;\n__webpack_require__.x = () => {\n\treturn __webpack_require__.e(531).then(next);\n};","export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\r\nexport function getRandomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\nexport function getRandomIntInclusive(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\r\n}\r\nexport function getRandomArbitrary(min, max) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Assumes that the object entries are all primitives + objects\r\n * shallow copy the object,\r\n * deep copy the\r\n * @param obj\r\n * @returns\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (!obj) return obj\r\n  if (!Object.keys(obj).length) return {} as T\r\n  const ret = { ...obj }\r\n  Object.entries(obj).forEach(([k, v]: any) => {\r\n    if (typeof v !== \"object\") return\r\n    ret[k] = JSON.parse(JSON.stringify(v))\r\n  })\r\n  return ret\r\n}\r\n\r\nexport const clamp = (val, low, high) => {\r\n  if (val < low) return low;\r\n  if (val > high) return high;\r\n  return val\r\n}\r\nexport const getArrLastElement = (arr) =>\r\n  arr.length ? arr[arr.length - 1] : null\r\n\r\nexport const clamp01 = (val) => clamp(val, 0, 1)\r\nexport const clampPercent = (val) => clamp(val, 0, 100)\r\n\r\n//use to pretty print timestamps, or anything really.\r\nexport function strPadLeft(string, pad, length) {\r\n  return (new Array(length + 1).join(pad) + string).slice(-length);\r\n}\r\n\r\n//fuzzy compare strings. longer the distance, the higher the mismatch.\r\nexport function hammingDistance(str1, str2) {\r\n  let dist = 0;\r\n  str1 = str1.toLowerCase();\r\n  str2 = str2.toLowerCase();\r\n  for (let i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\r\n    let match = true\r\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\r\n      match = false\r\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\r\n      match = true\r\n    if (!match) dist++\r\n  }\r\n  return dist;\r\n}\r\n\r\n//multiplies every numerical value in the obj by a multiplier.\r\nexport function objMultiplication(obj, multi) {\r\n  if (multi === 1) return obj\r\n  Object.keys(obj).forEach((prop: any) => {\r\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\r\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\r\n  })\r\n  return obj\r\n}\r\n\r\n//assign obj.[keys...] = value\r\nexport function layeredAssignment(obj, keys: readonly string[], value) {\r\n  keys.reduce((accu, key, i, arr) => {\r\n    if (i === arr.length - 1) return (accu[key] = value)\r\n    if (!accu[key]) accu[key] = {}\r\n    return accu[key]\r\n  }, obj)\r\n  return obj\r\n}\r\n//get the value in a nested object, giving array of path\r\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\r\n  if (!obj || !keys) return undefined;\r\n  !Array.isArray(keys) && console.error(keys)\r\n  return keys.reduce((a, k) => a?.[k], obj)\r\n}\r\n//delete the value denoted by the path. Will also delete empty objects as well.\r\nexport function deletePropPath(obj, path) {\r\n  const tempPath = [...path]\r\n  const lastKey = tempPath.pop()\r\n  const objPathed = objPathValue(obj, tempPath)\r\n  delete objPathed?.[lastKey];\r\n}\r\n\r\nexport function objClearEmpties(o) {\r\n  for (const k in o) {\r\n    if (typeof o[k] !== \"object\") continue\r\n    objClearEmpties(o[k])\r\n    if (!Object.keys(o[k]).length) delete o[k];\r\n  }\r\n}\r\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\r\n  if (validate(obj, keys)) cb(obj, keys)\r\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\r\n}\r\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\r\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\r\n\r\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\r\n  return typeof value === \"function\" ? (value as any)(arg) : value\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T, i: number) => [K, V]): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\r\n}\r\n\r\nexport function objectMap<K extends string, V, T>(obj: Record<K, Exclude<V, undefined>>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\r\n  return Object.fromEntries(Object.entries(obj).map(\r\n    ([k, v], i) => [k, fn(v, k, i)]\r\n  )) as any\r\n}\r\n\r\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\r\n  for (let i = from; i <= to; i++) yield i;\r\n};\r\n\r\n/** range of [from, to], inclusive */\r\nexport function range(from: number, to: number): number[] {\r\n  return [...rangeGen(from, to)]\r\n}\r\n\r\nexport function assertUnreachable(value: never): never {\r\n  throw new Error(`Should not reach this with value ${value}`)\r\n}\r\n\r\n/** Will change `arr` in-place */\r\nexport function toggleInArr<T>(arr: T[], value: T) {\r\n  const ind = arr.indexOf(value)\r\n  if (ind < 0) arr.push(value)\r\n  else arr.splice(ind, 1)\r\n}\r\n\r\nexport function toggleArr<T>(arr: T[], value: T) {\r\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\r\n}\r\n\r\nexport function deepFreeze<T>(obj: T, layers = 5): T {\r\n  if (layers === 0) return obj\r\n  if (typeof obj === \"object\")\r\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\r\n  return obj\r\n}\r\n\r\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\r\n  if (newIndex < 0 || newIndex >= arr.length) return arr\r\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\r\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n  return arr\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { OptNode } from \"./optimization\"\r\nimport type { ComputeNode, ConstantNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, StrPrioNode, SubscriptNode, ThresholdNode } from \"./type\"\r\n\r\ntype Opt = number | OptNode\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype N_S = Num | Str\r\ntype AnyNode = NumNode | StrNode\r\n\r\nexport const todo: OptNode = constant(NaN, { name: \"TODO\" })\r\nexport const one = percent(1), naught = percent(0)\r\nexport const none = constant(\"none\")\r\n\r\nexport function constant(value: number, info?: Info): ConstantNode<number>\r\nexport function constant(value: string | undefined, info?: Info): ConstantNode<string | undefined>\r\nexport function constant(value: number | string | undefined, info?: Info): ConstantNode<number> | ConstantNode<string | undefined>\r\nexport function constant(value: number | string | undefined, info?: Info): ConstantNode<number | string | undefined> {\r\n  return typeof value === \"number\"\r\n    ? { operation: \"const\", operands: [], type: \"number\", value, info }\r\n    : { operation: \"const\", operands: [], type: \"string\", value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): ConstantNode<number> {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { unit: \"%\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: OptNode, info: Info): OptNode\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: AnyNode, info: Info): AnyNode\r\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): LookupNode<NumNode>\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): LookupNode<StrNode>\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: N_S | \"none\", info?: Info): LookupNode<AnyNode> {\r\n  return { operation: \"lookup\", operands: defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] : [intoV(index)], table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Opt[]): ComputeNode<OptNode, OptNode>\r\nexport function min(...values: Num[]): ComputeNode\r\nexport function min(...values: Num[]): ComputeNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Opt[]): ComputeNode<OptNode, OptNode>\r\nexport function max(...values: Num[]): ComputeNode\r\nexport function max(...values: Num[]): ComputeNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Opt[]): ComputeNode<OptNode, OptNode>\r\nexport function sum(...values: Num[]): ComputeNode\r\nexport function sum(...values: Num[]): ComputeNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Opt[]): ComputeNode<OptNode, OptNode>\r\nexport function prod(...values: Num[]): ComputeNode\r\nexport function prod(...values: Num[]): ComputeNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Opt, c: Opt): ComputeNode<OptNode, OptNode>\r\nexport function frac(x: Num, c: Num): ComputeNode\r\nexport function frac(x: Num, c: Num): ComputeNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Opt): ComputeNode<OptNode, OptNode>\r\nexport function res(base: Num): ComputeNode\r\nexport function res(base: Num): ComputeNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? eq : neq */\r\nexport function compareEq(v1: Num, v2: Num, eq: Num, neq: Num, info?: Info): MatchNode<NumNode>\r\nexport function compareEq(v1: Num, v2: Num, eq: Str, neq: Str, info?: Info): MatchNode<StrNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Num, neq: Num, info?: Info): MatchNode<NumNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Str, neq: Str, info?: Info): MatchNode<StrNode>\r\nexport function compareEq(v1: N_S, v2: N_S, eq: N_S, neq: N_S, info?: Info): MatchNode<AnyNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)], info }\r\n}\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode>\r\nexport function equal(v1: N_S, v2: N_S, pass: Num, info?: Info): MatchNode<NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)], emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode>\r\nexport function equalStr(v1: N_S, v2: N_S, pass: Str, info?: Info): MatchNode<StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)], emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<NumNode>\r\nexport function unequal(v1: N_S, v2: N_S, pass: Num, info?: Info): MatchNode<NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)], emptyOn: \"match\" }\r\n}\r\n/** v1 != v2 ? pass : `undefined` */\r\nexport function unequalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<StrNode>\r\nexport function unequalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode>\r\nexport function unequalStr(v1: N_S, v2: N_S, pass: Str, info?: Info): MatchNode<StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(undefined), intoVInfo(pass, info)], emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Opt, v2: Opt, pass: Opt, info?: Info): ThresholdNode<OptNode, OptNode, OptNode>\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode>\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode> {\r\n  return { operation: \"threshold\", operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(0)], emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): ThresholdNode<StrNode> {\r\n  return { operation: \"threshold\", operands: [intoV(v1), intoV(v2), intoVInfo(pass, info), intoV(undefined)], emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Opt, v2: Opt, pass: Opt, info?: Info): ThresholdNode<OptNode, OptNode, OptNode>\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode>\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode> {\r\n  return { operation: \"threshold\", operands: [intoV(v1), intoV(v2), intoV(0), intoVInfo(pass, info)], emptyOn: \"ge\" }\r\n}\r\n/** v1 >= v2 ? ge : le */\r\nexport function threshold(v1: Opt, v2: Opt, ge: Opt, le: Opt, info?: Info): ThresholdNode<OptNode, OptNode, OptNode>\r\nexport function threshold(v1: Num, v2: Num, ge: Num, le: Num, info?: Info): ThresholdNode<NumNode>\r\nexport function threshold(v1: Num, v2: Num, ge: Num, le: Num, info?: Info): ThresholdNode<NumNode> {\r\n  return { operation: \"threshold\", operands: [intoV(v1), intoV(v2), intoV(ge), intoV(le)], info }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<NumNode> | DataNode<StrNode> {\r\n  return { operation: \"data\", operands: [base as any], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): DataNode<NumNode>\r\nexport function resetData(base: StrNode, data: Data, info?: Info): DataNode<StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<AnyNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\n/**\r\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\r\n */\r\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrPrioNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: N_S[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: N_S): AnyNode\r\nfunction intoV(value: N_S): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\nfunction intoVInfo(value: Num, info: Info | undefined): NumNode\r\nfunction intoVInfo(value: Str, info: Info | undefined): StrNode\r\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode\r\nfunction intoVInfo(value: N_S, info: Info | undefined): AnyNode {\r\n  if (!info) return intoV(value)\r\n  return (typeof value !== \"object\") ? constant(value, info) : infoMut({ ...value }, info)\r\n}\r\n\r\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n","import { AnyNode, Base, NodeData, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function deepNodeClone<T extends NodeData<NumNode | StrNode | undefined>>(data: T): T {\r\n  const map = new Map()\r\n  function internal(orig: any) {\r\n    if (typeof orig !== \"object\") return orig\r\n    const old = map.get(orig)\r\n    if (old) return old\r\n\r\n    const cache: any = Array.isArray(orig)\r\n      ? orig.map(val => internal(val))\r\n      : Object.fromEntries(Object.entries(orig).map(([key, val]) =>\r\n        [key, key === \"info\" ? val : internal(val)]))\r\n    map.set(orig, cache)\r\n    return cache\r\n  }\r\n  return internal(data)\r\n}\r\n\r\nexport function forEachNodes<T extends Base<T> = AnyNode>(formulas: T[], topDown: (formula: T) => void, bottomUp: (formula: T) => void): void {\r\n  const visiting = new Set<T>(), visited = new Set<T>()\r\n\r\n  function traverse(formula: T) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas<Input extends Base<Input> = AnyNode, Interim extends Base<Interim> = Input, Output extends Base<Output> = Interim>(formulas: Input[], topDownMap: (formula: Input | Interim) => Interim, bottomUpMap: (current: Interim | Output, orig: Input | Interim) => Output): Output[] {\r\n  const visiting = new Set<Input | Interim>()\r\n  const topDownMapped = new Map<Input | Interim, Output>()\r\n  const bottomUpMapped = new Map<Interim, Output>()\r\n\r\n  function check(formula: Input | Interim): Output {\r\n    let topDown: Interim | Output | undefined = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN) as any\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: Interim): Interim | Output {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual<Interim | Output>(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual<Input | Output>(result, formulas) ? formulas as any : result\r\n}\r\n\r\nexport function customMapFormula<Context, Output, Input extends Base<Input>>(formulas: Input[], context: Context, map: (formula: Input, context: Context, map: (node: Input, context: Context) => Output) => Output): Output[] {\r\n  const contextMapping = new Map<Context, [Set<Input>, Map<Input, Output>]>()\r\n  function internalMap(formula: Input, context: Context): Output {\r\n    let current = contextMapping.get(context)\r\n    if (!current) contextMapping.set(context, current = [new Set(), new Map()])\r\n    const [visiting, mapping] = current\r\n\r\n    const old = mapping.get(formula)\r\n    if (old) return old\r\n\r\n    if (visiting.has(formula))\r\n      throw new Error(\"Found cyclical dependency during formula mapping\")\r\n\r\n    visiting.add(formula)\r\n    const newFormula = map(formula, context, internalMap)\r\n    mapping.set(formula, newFormula)\r\n    visiting.delete(formula)\r\n\r\n    return newFormula\r\n  }\r\n  return formulas.map(formula => internalMap(formula, context))\r\n}\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import type { DynStat } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\r\nimport { assertUnreachable, objPathValue } from \"../Util/Util\"\r\nimport { customMapFormula, forEachNodes, mapFormulas } from \"./internal\"\r\nimport { AnyNode, CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode, ThresholdNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport type OptNode = ComputeNode<OptNode, OptNode> | ThresholdNode<OptNode, OptNode, OptNode> |\r\n  ReadNode<number> | ConstantNode<number>\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): OptNode[] {\r\n  let opts = constantFold(formulas, topLevelData, shouldFold)\r\n  opts = flatten(opts)\r\n  return deduplicate(opts)\r\n}\r\n\r\n/**\r\n * Compile an array of `formulas` into a JS `Function`\r\n *\r\n * @param formulas\r\n * @param initial base stats for the formula\r\n * @param binding\r\n * @param slotCount the number of slots in the build (usually 5)\r\n * @returns\r\n */\r\nexport function precompute(formulas: OptNode[], initial: DynStat, binding: (readNode: ReadNode<number>) => string, slotCount: number): (_: { values: DynStat }[]) => number[] {\r\n  // res copied from the code above\r\n  let body = `\r\n\"use strict\";\r\nfunction res(res) {\r\n  if (res < 0) return 1 - res / 2\r\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n  return 1 - res\r\n}\r\nconst x0=0`; // making sure `const` has at least one entry\r\n\r\n  let i = 1;\r\n  const names = new Map<NumNode | StrNode, string>()\r\n  forEachNodes(formulas, _ => {/* */ }, f => {\r\n    const { operation, operands } = f, name = `x${i++}`, operandNames = operands.map((x: OptNode) => names.get(x)!)\r\n    names.set(f, name)\r\n    switch (operation) {\r\n      case \"read\": {\r\n        const key = binding(f)\r\n        let arr = new Array(slotCount).fill(null).map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\r\n        if (initial[key] && initial[key] !== 0) {\r\n          arr = [initial[key].toString(), ...arr]\r\n        }\r\n        body += `,${name}=${arr.join('+')}\\n`\r\n        break\r\n      }\r\n      case \"const\": names.set(f, `(${f.value})`); break\r\n      case \"add\": case \"mul\": body += `,${name}=${operandNames.join(operation === \"add\" ? \"+\" : \"*\")}\\n`; break\r\n      case \"min\": case \"max\": body += `,${name}=Math.${operation}(${operandNames})\\n`; break\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandNames\r\n        body += `,${name}=(${value}>=${threshold})?${pass}:${fail}\\n`\r\n        break\r\n      }\r\n      case \"res\": body += `,${name}=res(${operandNames[0]})\\n`; break\r\n      case \"sum_frac\": body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})\\n`; break\r\n\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n  body += `;\\nreturn [${formulas.map(f => names.get(f)!)}]`\r\n  return new (Function as any)(`b`, body)\r\n}\r\n\r\nfunction flatten(formulas: OptNode[]): OptNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as Operation)) {\r\n      const formula = _formula as ComputeNode<OptNode>\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: OptNode[]): OptNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<OptNode, number>(),\r\n      formulas: new Set<OptNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  for (; ;) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode<OptNode> = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    const candidatesByOperation = new Map<Operation, [ComputeNode<OptNode>, Map<OptNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula)) {\r\n        const formula = _formula as ComputeNode<OptNode>\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode<OptNode>\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<OptNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<OptNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): OptNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, OptNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return customMapFormula<typeof context, OptNode | StrNode, AnyNode>(formulas, context, (formula, context, map) => {\r\n    const { operation } = formula, fold = (x: NumNode, c: typeof context) => map(x, c) as OptNode\r\n    const foldStr = (x: StrNode, c: typeof context) => map(x, c) as StrNode\r\n    let result: OptNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": result = formula; break\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: OptNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = foldStr(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = map(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = foldStr(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? foldStr(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = foldStr(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => map(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => map(x, context) as OptNode)\r\n        if (pass.operation === \"const\" && fail.operation === \"const\" && pass.value === fail.value)\r\n          result = pass\r\n        else if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation !== \"const\")\r\n          throw new Error(\"Found non-constant subscript node while folding\")\r\n        result = constant(formula.list[index.value])\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = map(operands[operands.length - 1], context)\r\n        else\r\n          result = map({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\": {\r\n        if (formula.reset) context = origin\r\n        const nextMap = nextContextMap.get(context)!\r\n        let nextContext = nextMap.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          nextMap.set(formula.data, nextContext)\r\n        }\r\n        result = map(formula.operands[0], nextContext)\r\n        break\r\n      }\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    if (result.info) {\r\n      result = { ...result }\r\n      delete result.info\r\n    }\r\n    return result\r\n  }) as OptNode[]\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","export const genderKeys = [\"F\", \"M\"] as const\r\nexport type Gender = typeof genderKeys[number]\r\n\r\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\r\nexport type ElementKey = typeof allElements[number]\r\n\r\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\r\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\r\n\r\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\r\nexport type Region = typeof allRegions[number]\r\n\r\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\r\nexport type Ascension = typeof allAscension[number]\r\n\r\nexport const nonTravelerCharacterKeys = [\r\n  \"Albedo\",\r\n  \"Alhaitham\",\r\n  \"Aloy\",\r\n  \"Amber\",\r\n  \"AratakiItto\",\r\n  \"Barbara\",\r\n  \"Beidou\",\r\n  \"Bennett\",\r\n  \"Candace\",\r\n  \"Chongyun\",\r\n  \"Collei\",\r\n  \"Cyno\",\r\n  \"Diluc\",\r\n  \"Diona\",\r\n  \"Dori\",\r\n  \"Eula\",\r\n  \"Faruzan\",\r\n  \"Fischl\",\r\n  \"Ganyu\",\r\n  \"Gorou\",\r\n  \"HuTao\",\r\n  \"Jean\",\r\n  \"KaedeharaKazuha\",\r\n  \"Kaeya\",\r\n  \"KamisatoAyaka\",\r\n  \"KamisatoAyato\",\r\n  \"Keqing\",\r\n  \"Klee\",\r\n  \"KujouSara\",\r\n  \"KukiShinobu\",\r\n  \"Layla\",\r\n  \"Lisa\",\r\n  \"Mona\",\r\n  \"Nahida\",\r\n  \"Nilou\",\r\n  \"Ningguang\",\r\n  \"Noelle\",\r\n  \"Qiqi\",\r\n  \"RaidenShogun\",\r\n  \"Razor\",\r\n  \"Rosaria\",\r\n  \"SangonomiyaKokomi\",\r\n  \"Sayu\",\r\n  \"Shenhe\",\r\n  \"ShikanoinHeizou\",\r\n  \"Sucrose\",\r\n  \"Tartaglia\",\r\n  \"Thoma\",\r\n  \"Tighnari\",\r\n  \"Venti\",\r\n  \"Wanderer\",\r\n  \"Xiangling\",\r\n  \"Xiao\",\r\n  \"Xingqiu\",\r\n  \"Xinyan\",\r\n  \"YaeMiko\",\r\n  \"Yanfei\",\r\n  \"Yaoyao\",\r\n  \"Yelan\",\r\n  \"Yoimiya\",\r\n  \"YunJin\",\r\n  \"Zhongli\",\r\n] as const\r\n\r\nexport const travelerKeys = [\r\n  \"TravelerAnemo\",\r\n  \"TravelerGeo\",\r\n  \"TravelerElectro\",\r\n  \"TravelerDendro\",\r\n] as const\r\nexport type TravelerKey = typeof travelerKeys[number]\r\n\r\nexport const locationGenderedCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  \"TravelerF\",\r\n  \"TravelerM\"\r\n] as const\r\nexport type LocationGenderedCharacterKey = typeof locationGenderedCharacterKeys[number]\r\n\r\nexport const allCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  ...travelerKeys\r\n] as const\r\nexport type CharacterKey = typeof allCharacterKeys[number]\r\n\r\nexport function characterKeyToLocationGenderedCharacterKey(charKey: CharacterKey, gender: Gender): LocationGenderedCharacterKey {\r\n  if (travelerKeys.includes(charKey as TravelerKey)) return `Traveler${gender}`\r\n  return charKey as LocationGenderedCharacterKey\r\n}\r\n","import { Rarity } from \"./common\"\r\n\r\nexport const allArtifactSets = [\r\n  \"Adventurer\",\r\n  \"ArchaicPetra\",\r\n  \"Berserker\",\r\n  \"BlizzardStrayer\",\r\n  \"BloodstainedChivalry\",\r\n  \"BraveHeart\",\r\n  \"CrimsonWitchOfFlames\",\r\n  \"DeepwoodMemories\",\r\n  \"DefendersWill\",\r\n  \"DesertPavilionChronicle\",\r\n  \"EchoesOfAnOffering\",\r\n  \"EmblemOfSeveredFate\",\r\n  \"FlowerOfParadiseLost\",\r\n  \"Gambler\",\r\n  \"GildedDreams\",\r\n  \"GladiatorsFinale\",\r\n  \"HeartOfDepth\",\r\n  \"HuskOfOpulentDreams\",\r\n  \"Instructor\",\r\n  \"Lavawalker\",\r\n  \"LuckyDog\",\r\n  \"MaidenBeloved\",\r\n  \"MartialArtist\",\r\n  \"NoblesseOblige\",\r\n  \"OceanHuedClam\",\r\n  \"PaleFlame\",\r\n  \"PrayersForDestiny\",\r\n  \"PrayersForIllumination\",\r\n  \"PrayersForWisdom\",\r\n  \"PrayersToSpringtime\",\r\n  \"ResolutionOfSojourner\",\r\n  \"RetracingBolide\",\r\n  \"Scholar\",\r\n  \"ShimenawasReminiscence\",\r\n  \"TenacityOfTheMillelith\",\r\n  \"TheExile\",\r\n  \"ThunderingFury\",\r\n  \"Thundersoother\",\r\n  \"TinyMiracle\",\r\n  \"TravelingDoctor\",\r\n  \"VermillionHereafter\",\r\n  \"ViridescentVenerer\",\r\n  \"WanderersTroupe\",\r\n] as const\r\nexport type ArtifactSetKey = typeof allArtifactSets[number]\r\n\r\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\r\nexport type SlotKey = typeof allSlotKeys[number]\r\n\r\nexport const artMaxLevel: Record<Rarity, number> = {\r\n  1: 4,\r\n  2: 4,\r\n  3: 12,\r\n  4: 16,\r\n  5: 20,\r\n} as const\r\n","import { Rarity } from \"./common\"\r\n\r\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\r\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\r\n\r\nexport const allWeaponSwordKeys = [\r\n  \"AmenomaKageuchi\",\r\n  \"AquilaFavonia\",\r\n  \"BlackcliffLongsword\",\r\n  \"CinnabarSpindle\",\r\n  \"CoolSteel\",\r\n  \"KagotsurubeIsshin\",\r\n  \"DarkIronSword\",\r\n  \"DullBlade\",\r\n  \"FavoniusSword\",\r\n  \"FesteringDesire\",\r\n  \"FilletBlade\",\r\n  \"FreedomSworn\",\r\n  \"HaranGeppakuFutsu\",\r\n  \"HarbingerOfDawn\",\r\n  \"IronSting\",\r\n  \"KeyOfKhajNisut\",\r\n  \"LightOfFoliarIncision\",\r\n  \"LionsRoar\",\r\n  \"MistsplitterReforged\",\r\n  \"PrimordialJadeCutter\",\r\n  \"PrototypeRancour\",\r\n  \"RoyalLongsword\",\r\n  \"SacrificialSword\",\r\n  \"SapwoodBlade\",\r\n  \"SilverSword\",\r\n  \"SkyriderSword\",\r\n  \"SkywardBlade\",\r\n  \"SummitShaper\",\r\n  \"SwordOfDescension\",\r\n  \"TheAlleyFlash\",\r\n  \"TheBlackSword\",\r\n  \"TheFlute\",\r\n  \"ToukabouShigure\",\r\n  \"TravelersHandySword\",\r\n  \"XiphosMoonlight\",\r\n] as const\r\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\r\n\r\nexport const allWeaponClaymoreKeys = [\r\n  \"Akuoumaru\",\r\n  \"BlackcliffSlasher\",\r\n  \"BloodtaintedGreatsword\",\r\n  \"DebateClub\",\r\n  \"FavoniusGreatsword\",\r\n  \"FerrousShadow\",\r\n  \"ForestRegalia\",\r\n  \"KatsuragikiriNagamasa\",\r\n  \"LithicBlade\",\r\n  \"LuxuriousSeaLord\",\r\n  \"MakhairaAquamarine\",\r\n  \"OldMercsPal\",\r\n  \"PrototypeArchaic\",\r\n  \"Rainslasher\",\r\n  \"RedhornStonethresher\",\r\n  \"RoyalGreatsword\",\r\n  \"SacrificialGreatsword\",\r\n  \"SerpentSpine\",\r\n  \"SkyriderGreatsword\",\r\n  \"SkywardPride\",\r\n  \"SnowTombedStarsilver\",\r\n  \"SongOfBrokenPines\",\r\n  \"TheBell\",\r\n  \"TheUnforged\",\r\n  \"WasterGreatsword\",\r\n  \"Whiteblind\",\r\n  \"WhiteIronGreatsword\",\r\n  \"WolfsGravestone\",\r\n] as const\r\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\r\n\r\nexport const allWeaponPolearmKeys = [\r\n  \"BeginnersProtector\",\r\n  \"BlackcliffPole\",\r\n  \"BlackTassel\",\r\n  \"CalamityQueller\",\r\n  \"CrescentPike\",\r\n  \"Deathmatch\",\r\n  \"DragonsBane\",\r\n  \"DragonspineSpear\",\r\n  \"EngulfingLightning\",\r\n  \"FavoniusLance\",\r\n  \"Halberd\",\r\n  \"IronPoint\",\r\n  \"KitainCrossSpear\",\r\n  \"LithicSpear\",\r\n  \"MissiveWindspear\",\r\n  \"Moonpiercer\",\r\n  \"PrimordialJadeWingedSpear\",\r\n  \"PrototypeStarglitter\",\r\n  \"RoyalSpear\",\r\n  \"SkywardSpine\",\r\n  \"StaffOfHoma\",\r\n  \"StaffOfTheScarletSands\",\r\n  \"TheCatch\",\r\n  \"VortexVanquisher\",\r\n  \"WavebreakersFin\",\r\n  \"WhiteTassel\",\r\n] as const\r\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\r\n\r\nexport const allWeaponBowKeys = [\r\n  \"AlleyHunter\",\r\n  \"AmosBow\",\r\n  \"AquaSimulacra\",\r\n  \"BlackcliffWarbow\",\r\n  \"CompoundBow\",\r\n  \"ElegyForTheEnd\",\r\n  \"EndOfTheLine\",\r\n  \"FadingTwilight\",\r\n  \"FavoniusWarbow\",\r\n  \"Hamayumi\",\r\n  \"HuntersBow\",\r\n  \"HuntersPath\",\r\n  \"KingsSquire\",\r\n  \"Messenger\",\r\n  \"MitternachtsWaltz\",\r\n  \"MouunsMoon\",\r\n  \"PolarStar\",\r\n  \"Predator\",\r\n  \"PrototypeCrescent\",\r\n  \"RavenBow\",\r\n  \"RecurveBow\",\r\n  \"RoyalBow\",\r\n  \"Rust\",\r\n  \"SacrificialBow\",\r\n  \"SeasonedHuntersBow\",\r\n  \"SharpshootersOath\",\r\n  \"SkywardHarp\",\r\n  \"Slingshot\",\r\n  \"TheStringless\",\r\n  \"TheViridescentHunt\",\r\n  \"ThunderingPulse\",\r\n  \"WindblumeOde\",\r\n] as const\r\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\r\n\r\nexport const allWeaponCatalystKeys = [\r\n  \"ApprenticesNotes\",\r\n  \"AThousandFloatingDreams\",\r\n  \"BlackcliffAgate\",\r\n  \"DodocoTales\",\r\n  \"EmeraldOrb\",\r\n  \"EverlastingMoonglow\",\r\n  \"EyeOfPerception\",\r\n  \"FavoniusCodex\",\r\n  \"Frostbearer\",\r\n  \"FruitOfFulfillment\",\r\n  \"HakushinRing\",\r\n  \"KagurasVerity\",\r\n  \"LostPrayerToTheSacredWinds\",\r\n  \"MagicGuide\",\r\n  \"MappaMare\",\r\n  \"MemoryOfDust\",\r\n  \"OathswornEye\",\r\n  \"OtherworldlyStory\",\r\n  \"PocketGrimoire\",\r\n  \"PrototypeAmber\",\r\n  \"RoyalGrimoire\",\r\n  \"SacrificialFragments\",\r\n  \"SkywardAtlas\",\r\n  \"SolarPearl\",\r\n  \"TheWidsith\",\r\n  \"ThrillingTalesOfDragonSlayers\",\r\n  \"TulaytullahsRemembrance\",\r\n  \"TwinNephrite\",\r\n  \"WanderingEvenstar\",\r\n  \"WineAndSong\",\r\n] as const\r\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\r\n\r\nexport const allWeaponKeys = [\r\n  ...allWeaponSwordKeys,\r\n  ...allWeaponClaymoreKeys,\r\n  ...allWeaponPolearmKeys,\r\n  ...allWeaponBowKeys,\r\n  ...allWeaponCatalystKeys,\r\n] as const\r\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\r\n\r\nexport const weaponMaxLevel: Record<Rarity, number> = {\r\n  1: 70,\r\n  2: 70,\r\n  3: 90,\r\n  4: 90,\r\n  5: 90,\r\n} as const\r\n","import { allArtifactSets, allWeaponBowKeys, allWeaponCatalystKeys, allWeaponClaymoreKeys, allWeaponPolearmKeys, allWeaponSwordKeys, nonTravelerCharacterKeys, WeaponBowKey, WeaponCatalystKey, WeaponClaymoreKey, WeaponPoleArmKey, WeaponSwordKey } from \"@genshin-optimizer/consts\"\n\nexport const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\nexport const allAmpReactions = [\"vaporize\", \"melt\",] as const\nexport const allAdditiveReactions = [\"spread\", \"aggravate\"] as const\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\nexport const allArtifactRarities = [5, 4, 3] as const\n/**\n * @deprecated\n */\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\n/**\n * @deprecated\n */\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\n/**\n * @deprecated\n */\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\nexport const allInfusionAuraElements = [\"pyro\", 'cryo', 'hydro'] as const\n/**\n * @deprecated\n */\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\nexport const allRollColorKeys = ['roll1', 'roll2', 'roll3', 'roll4', 'roll5', 'roll6'] as const\n/**\n * @deprecated\n */\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\nexport const allRefinement = [1, 2, 3, 4, 5] as const\nexport const substatType = [\"max\", \"mid\", \"min\"] as const\nexport const genderKeys = [\"F\", \"M\"] as const\nexport type Gender = typeof genderKeys[number]\n\nexport const locationCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  \"Traveler\",\n] as const\nexport const travelerElements = [\n  \"anemo\",\n  \"geo\",\n  \"electro\",\n  \"dendro\"\n] as const\nexport const travelerFKeys = [\n  \"TravelerAnemoF\",\n  \"TravelerGeoF\",\n  \"TravelerElectroF\",\n  \"TravelerDendroF\",\n] as const\nexport const travelerMKeys = [\n  \"TravelerAnemoM\",\n  \"TravelerGeoM\",\n  \"TravelerElectroM\",\n  \"TravelerDendroM\",\n] as const\n/**\n * @deprecated\n */\nexport const travelerKeys = [\n  \"TravelerAnemo\",\n  \"TravelerGeo\",\n  \"TravelerElectro\",\n  \"TravelerDendro\",\n] as const\n/**\n * @deprecated\n */\nexport const allCharacterKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerKeys\n] as const\n\nexport const allCharacterSheetKeys = [\n  ...nonTravelerCharacterKeys,\n  ...travelerFKeys,\n  ...travelerMKeys,\n]\n\n/**\n * @deprecated\n */\nexport const allWeaponKeys = [\n  ...allWeaponSwordKeys,\n  ...allWeaponClaymoreKeys,\n  ...allWeaponPolearmKeys,\n  ...allWeaponBowKeys,\n  ...allWeaponCatalystKeys,\n] as const\n/**\n * @deprecated\n */\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\n\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"dendro_dmg_\"] as const\n\nexport type HitModeKey = typeof allHitModes[number]\nexport type AmpReactionKey = typeof allAmpReactions[number]\nexport type AdditiveReactionKey = typeof allAdditiveReactions[number]\nexport type SetNum = typeof allArtifactSetCount[number]\nexport type ArtifactRarity = typeof allArtifactRarities[number]\n/**\n * @deprecated\n */\nexport type SlotKey = typeof allSlotKeys[number]\n/**\n * @deprecated\n */\nexport type ElementKey = typeof allElements[number]\n/**\n * @deprecated\n */\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\nexport type InfusionAuraElements = typeof allInfusionAuraElements[number]\n/**\n * @deprecated\n */\nexport type ArtifactSetKey = typeof allArtifactSets[number]\n/**\n * @deprecated\n */\nexport type CharacterKey = typeof allCharacterKeys[number]\nexport type CharacterSheetKey = typeof allCharacterSheetKeys[number]\nexport type LocationCharacterKey = typeof locationCharacterKeys[number]\n/**\n * @deprecated\n */\nexport type TravelerKey = typeof travelerKeys[number]\nexport type TravelerElementKey = typeof travelerElements[number]\n/**\n * @deprecated\n */\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\nexport type RollColorKey = typeof allRollColorKeys[number]\n/**\n * @deprecated\n */\nexport type Ascension = typeof allAscension[number]\nexport type Refinement = typeof allRefinement[number]\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\n  pyro: [\"vaporize\", \"melt\"],\n  hydro: [\"vaporize\"],\n  cryo: [\"melt\"],\n  anemo: [\"vaporize\", \"melt\"],\n}\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> = {\n  dendro: [\"spread\"],\n  electro: [\"aggravate\"],\n  anemo: [\"aggravate\"],\n}\n\nexport type SubstatType = typeof substatType[number]\n\nexport function charKeyToLocCharKey(charKey: CharacterKey): LocationCharacterKey {\n  if (travelerKeys.includes(charKey as TravelerKey)) return \"Traveler\"\n  return charKey as LocationCharacterKey\n}\n\nexport function TravelerToElement(key: TravelerKey, element: TravelerElementKey): TravelerKey {\n  return \"Traveler\" + element.toUpperCase().slice(0, 1) + element.slice(1) as TravelerKey\n}\n\nexport type LocationKey = LocationCharacterKey | \"\"\n\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\n  return ck.startsWith(\"Traveler\") ? \"Traveler\" + gender : ck\n}\n","import { ArtSetExclusion } from \"../../../../Database/DataManagers/BuildSettingData\";\r\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\r\nimport { allOperations, constantFold, OptNode } from \"../../../../Formula/optimization\";\r\nimport { ConstantNode } from \"../../../../Formula/type\";\r\nimport { constant, customRead, max, min, threshold } from \"../../../../Formula/utils\";\r\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\r\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\r\n\r\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\r\nexport function pruneAll(nodes: OptNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: OptNode[], arts: ArtifactsBySlot } {\r\n  let should = forced\r\n  /** If `key` makes progress, all operations in `value` should be performed */\r\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\r\n    pruneOrder: { pruneNodeRange: true },\r\n    pruneArtRange: { pruneNodeRange: true },\r\n    pruneNodeRange: { reaffine: true },\r\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\r\n  }\r\n  let count = 0\r\n  while (Object.values(should).some(x => x) && count++ < 20) {\r\n    if (should.pruneOrder) {\r\n      delete should.pruneOrder\r\n      const newArts = pruneOrder(arts, numTop, exclusion)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneOrder }\r\n      }\r\n    }\r\n    if (should.pruneArtRange) {\r\n      delete should.pruneArtRange\r\n      const newArts = pruneArtRange(nodes, arts, minimum)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneArtRange }\r\n      }\r\n    }\r\n    if (should.pruneNodeRange) {\r\n      delete should.pruneNodeRange\r\n      const newNodes = pruneNodeRange(nodes, arts)\r\n      if (nodes !== newNodes) {\r\n        nodes = newNodes\r\n        should = { ...should, ...deps.pruneNodeRange }\r\n      }\r\n    }\r\n    if (should.reaffine) {\r\n      delete should.reaffine\r\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\r\n      if (nodes !== newNodes || arts !== newArts) {\r\n        nodes = newNodes\r\n        arts = newArts\r\n        should = { ...should, ...deps.reaffine }\r\n      }\r\n    }\r\n  }\r\n  return { nodes, arts }\r\n}\r\n\r\nexport function pruneExclusion(nodes: OptNode[], exclusion: ArtSetExclusion): OptNode[] {\r\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\r\n  for (const [key, e] of Object.entries(exclusion)) {\r\n    if (!e.includes(4)) continue\r\n    maxValues[key] = e.includes(2) ? 1 : 3\r\n  }\r\n  return mapFormulas(nodes, f => f, f => {\r\n    if (f.operation !== \"threshold\") return f\r\n\r\n    const [v, t, pass, fail] = f.operands\r\n    if (v.operation === \"read\" && t.operation === \"const\") {\r\n      const key = v.path[v.path.length - 1], thres = t.value\r\n      if (key in maxValues) {\r\n        const max: number = maxValues[key]\r\n        if (max < thres) return fail\r\n        if (thres === 2 && exclusion[key]!.includes(2))\r\n          return threshold(v, 4, pass, fail)\r\n      }\r\n    }\r\n    return f\r\n  })\r\n}\r\n\r\nfunction reaffine(nodes: OptNode[], arts: ArtifactsBySlot, forceRename = false): { nodes: OptNode[], arts: ArtifactsBySlot } {\r\n  const affineNodes = new Set<OptNode>(), topLevelAffine = new Set<OptNode>()\r\n\r\n  function visit(node: OptNode, isAffine: boolean) {\r\n    if (isAffine) affineNodes.add(node)\r\n    else node.operands.forEach(op => affineNodes.has(op) && topLevelAffine.add(op))\r\n  }\r\n\r\n  const dynKeys = new Set<string>()\r\n\r\n  forEachNodes(nodes, _ => { }, f => {\r\n    const { operation } = f\r\n    switch (operation) {\r\n      case \"read\":\r\n        dynKeys.add(f.path[1])\r\n        visit(f, true)\r\n        break\r\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\r\n      case \"mul\": {\r\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\r\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\r\n        break\r\n      }\r\n      case \"const\": visit(f, true); break\r\n      case \"res\": case \"threshold\": case \"sum_frac\":\r\n      case \"max\": case \"min\": visit(f, false); break\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\r\n    Object.keys(arts.base).length === dynKeys.size)\r\n    return { nodes, arts }\r\n\r\n  let current = -1\r\n  function nextDynKey(): string {\r\n    while (dynKeys.has(`${++current}`));\r\n    return `${current}`\r\n  }\r\n\r\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\r\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\r\n  const affineMap = new Map(affine.map(node => [node,\r\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\r\n      ? node\r\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\r\n  nodes = mapFormulas(nodes, f => affineMap.get(f) ?? f, f => f)\r\n\r\n  function reaffineArt(stat: DynStat): DynStat {\r\n    const values = constantFold([...affineMap.keys()], {\r\n      dyn: objectMap(stat, (value) => constant(value))\r\n    } as any, _ => true)\r\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\r\n  }\r\n  const result = {\r\n    nodes, arts: {\r\n      base: reaffineArt(arts.base),\r\n      values: objectKeyMap(allSlotKeys, slot =>\r\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\r\n    }\r\n  }\r\n  const offsets = Object.entries(reaffineArt({}))\r\n  for (const arts of Object.values(result.arts.values))\r\n    for (const { values } of arts)\r\n      for (const [key, baseValue] of offsets)\r\n        values[key] -= baseValue\r\n  return result\r\n}\r\n/** Remove artifacts that cannot be in top `numTop` builds */\r\nfunction pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\r\n  let progress = false\r\n  /**\r\n   * Note:\r\n   * This function assumes that every base (reaffined) stats are monotonically increasing. That is, artifacts\r\n   * with higher stats are better. This remains true as long as the main and substats are in increasing. Set\r\n   * effects that decrease enemy resistance (which is monotonically decreasing) does not violate this assumption\r\n   * as set effects are not handled here.\r\n   */\r\n  const allowRainbow = !exclusion.rainbow?.length, keys = Object.keys(arts.base)\r\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\r\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\r\n  const values = objectKeyMap(allSlotKeys, slot => {\r\n    const list = arts.values[slot]\r\n    const newList = list.filter(art => {\r\n      let count = 0\r\n      return list.every(other => {\r\n        const otherBetterEqual = keys.every(k => (other.values[k] ?? 0) >= (art.values[k] ?? 0))\r\n        const otherMaybeBetter = keys.some(k => (other.values[k] ?? 0) > (art.values[k] ?? 0))\r\n        const otherBetter = otherBetterEqual && (otherMaybeBetter || other.id > art.id)\r\n        const canSwitch = (allowRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set\r\n        if (otherBetter && canSwitch) count++\r\n        return count < numTop\r\n      })\r\n    })\r\n    if (newList.length !== list.length) progress = true\r\n    return newList\r\n  })\r\n  return progress ? { base: arts.base, values } : arts\r\n}\r\n/** Remove artifacts that cannot reach `minimum` in any build */\r\nfunction pruneArtRange(nodes: OptNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const wrap = { arts }\r\n  while (true) {\r\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\r\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\r\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\r\n\r\n    let progress = false\r\n    const values = objectKeyMap(allSlotKeys, slot => {\r\n      const result = wrap.arts.values[slot].filter(art => {\r\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\r\n        const newRange = computeNodeRange(nodes, read)\r\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\r\n      })\r\n      if (result.length !== wrap.arts.values[slot].length)\r\n        progress = true\r\n      return result\r\n    })\r\n    if (!progress) break\r\n    wrap.arts = { base: wrap.arts.base, values }\r\n  }\r\n  return wrap.arts\r\n}\r\nfunction pruneNodeRange(nodes: OptNode[], arts: ArtifactsBySlot): OptNode[] {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n  const nodeRange = computeNodeRange(nodes, reads)\r\n\r\n  return mapFormulas(nodes, f => {\r\n    {\r\n      const { min, max } = nodeRange.get(f)!\r\n      if (min === max) return constant(min)\r\n    }\r\n    const { operation } = f\r\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\r\n    switch (operation) {\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandRanges\r\n        if (value.min >= threshold.max) return f.operands[2]\r\n        else if (value.max < threshold.min) return f.operands[3]\r\n        if (pass.max === pass.min &&\r\n          fail.max === fail.min &&\r\n          pass.min === fail.min && isFinite(pass.min))\r\n          return constant(pass.max)\r\n        break\r\n      }\r\n      case \"min\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\r\n        break\r\n      }\r\n      case \"max\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every(op2 => op1.max >= op2.min)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\r\n        break\r\n      }\r\n    }\r\n    return f\r\n  }, f => f)\r\n}\r\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  ranges.forEach(range => {\r\n    Object.entries(range).forEach(([key, value]) => {\r\n      if (result[key]) {\r\n        result[key].min += value.min\r\n        result[key].max += value.max\r\n      } else result[key] = { ...value }\r\n    })\r\n  })\r\n  return result\r\n}\r\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  if (arts.length) {\r\n    Object.keys(arts[0].values)\r\n      .filter(key => arts.every(art => art.values[key]))\r\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\r\n    arts.forEach(({ values }) => {\r\n      for (const [key, value] of Object.entries(values)) {\r\n        if (!result[key]) result[key] = { min: 0, max: value }\r\n        else {\r\n          if (result[key].max < value) result[key].max = value\r\n          if (result[key].min > value) result[key].min = value\r\n        }\r\n      }\r\n    })\r\n  }\r\n  return result\r\n}\r\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  return addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n}\r\nexport function computeNodeRange(nodes: OptNode[], reads: DynMinMax): Map<OptNode, MinMax> {\r\n  const range = new Map<OptNode, MinMax>()\r\n\r\n  forEachNodes(nodes, _ => { }, f => {\r\n    const { operation } = f\r\n    const operands = f.operands.map(op => range.get(op)!)\r\n    let current: MinMax\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.path[0] !== \"dyn\")\r\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\r\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\r\n        break\r\n      case \"const\": current = computeMinMax([f.value]); break\r\n      case \"add\": case \"min\": case \"max\":\r\n        current = {\r\n          min: allOperations[operation](operands.map(x => x.min)),\r\n          max: allOperations[operation](operands.map(x => x.max)),\r\n        }; break\r\n      case \"res\": current = {\r\n        min: allOperations[operation]([operands[0].max]),\r\n        max: allOperations[operation]([operands[0].min]),\r\n      }; break\r\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\r\n        accu.min * current.min, accu.min * current.max,\r\n        accu.max * current.min, accu.max * current.max,\r\n      ])); break\r\n      case \"threshold\":\r\n        if (operands[0].min >= operands[1].max) current = operands[2]\r\n        else if (operands[0].max < operands[1].min) current = operands[3]\r\n        else current = computeMinMax([], [operands[2], operands[3]])\r\n        break\r\n      case \"sum_frac\": {\r\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\r\n        if (sum.min <= 0 && sum.max >= 0)\r\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\r\n        else\r\n          // TODO: Check this\r\n          current = computeMinMax([\r\n            x.min / sum.min, x.min / sum.max,\r\n            x.max / sum.min, x.max / sum.max\r\n          ])\r\n        break\r\n      }\r\n      default: assertUnreachable(operation)\r\n    }\r\n    range.set(f, current)\r\n  })\r\n  return range\r\n}\r\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\r\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\r\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\r\n  return { min, max }\r\n}\r\n\r\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\r\n  return {\r\n    base: arts.base,\r\n    values: objectKeyMap(allSlotKeys, slot => {\r\n      const filter = filters[slot]\r\n      switch (filter.kind) {\r\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\r\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\r\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\r\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\r\n}\r\nexport function mergePlot(plots: PlotData[]): PlotData {\r\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\r\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\r\n  while (keys.size > maxCount) {\r\n    scale *= reductionScaling\r\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\r\n  }\r\n  const result: PlotData = {}\r\n  for (const plot of plots)\r\n    for (const build of Object.values(plot)) {\r\n      const x = Math.round(build.plot! / scale) * scale\r\n      if (!result[x] || result[x]!.value < build.value)\r\n        result[x] = build\r\n    }\r\n  return result\r\n}\r\n\r\nexport function countBuilds(arts: ArtifactsBySlot): number {\r\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\r\n}\r\n\r\n\r\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\r\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\r\n  filter_loop: for (const filter of filters) {\r\n    for (const [slot, f] of Object.entries(filter)) {\r\n      const available = artSets[slot]!\r\n      switch (f.kind) {\r\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\r\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\r\n        case \"id\": break\r\n      }\r\n    }\r\n    yield filter\r\n  }\r\n}\r\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\r\n  return new Set(exclusion?.includes(2)\r\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\r\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\r\n}\r\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\r\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\r\n  /**\r\n   * This generation algorithm is separated into two parts:\r\n   * - \"Shape\" generation\r\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\r\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\r\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\r\n   * - Shape filling\r\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\r\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\r\n   */\r\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\r\n  let shapes: number[][] = []\r\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\r\n    if (current.length === 5) {\r\n      if (allowedRainbows.has(rainbows.length))\r\n        shapes.push(current)\r\n      return\r\n    }\r\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\r\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\r\n  }\r\n  populateShapes([0], new Set([0]), [0])\r\n  function indexOfShape(shape: number[], replacing: number) {\r\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\r\n      return undefined\r\n    shape = [...shape]\r\n    shape[replacing] = 5\r\n    return shape.reduce((a, b) => a * 6 + b, 0)\r\n  }\r\n  for (let replacing = 4; replacing >= 0; replacing--) {\r\n    const required: Map<number, number> = new Map()\r\n    for (const shape of shapes) {\r\n      const id = indexOfShape(shape, replacing)\r\n      if (id === undefined) continue\r\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\r\n    }\r\n    for (const [id, remaining] of required.entries()) {\r\n      if (remaining === 0) {\r\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\r\n        shape[replacing] = 5\r\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\r\n        shapes.push(shape)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shapes are now calculated and merged, proceed to fill in the sets\r\n\r\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\r\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\r\n\r\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\r\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\r\n\r\n  function* check(shape: number[]) {\r\n    const used: Set<ArtifactSetKey> = new Set()\r\n    let groupped: number[][] = [], rainbows: number[] = []\r\n    for (const i of shape) {\r\n      groupped.push([])\r\n      if (i === 5) rainbows.push(groupped.length - 1)\r\n      else groupped[i].push(groupped.length - 1)\r\n    }\r\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\r\n    let usableRainbows = rainbows.length\r\n\r\n    // Inception.. because js doesn't like functions inside a for-loop\r\n    function* check(i: number) {\r\n      if (i === groupped.length)\r\n        return yield* check_free(0)\r\n\r\n      for (const set of artSets) {\r\n        if (used.has(set)) continue\r\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\r\n        let requiredRainbows = 0\r\n\r\n        if (allowedSet && !allowedSet.has(length)) {\r\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\r\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\r\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\r\n        }\r\n\r\n        used.add(set)\r\n        counts[set] = groupped[i].length\r\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\r\n        usableRainbows -= requiredRainbows\r\n\r\n        yield* check(i + 1)\r\n\r\n        usableRainbows += requiredRainbows\r\n        counts[set] = 0\r\n        used.delete(set)\r\n      }\r\n    }\r\n    // We separate filling rainbow slots from groupped slots because it has an entirely\r\n    // different set of rules regarding what can be filled and what states to be kept.\r\n    function* check_free(i: number) {\r\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\r\n      let required = 0\r\n      for (const set of artSets) {\r\n        const allowedSet = allowedCounts[set], count = counts[set]\r\n        if (!allowedSet) continue\r\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\r\n        else if (!allowedSet.has(count)) {\r\n          required += [...allowedSet].find(x => x > count)! - count\r\n          missing.push(set)\r\n        }\r\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\r\n      }\r\n      if (required > remaining) return\r\n      if (i === rainbows.length) {\r\n        yield { ...result }\r\n        return\r\n      }\r\n      if (required === remaining) {\r\n        for (const set of missing) {\r\n          counts[set]++\r\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n          yield* check_free(i + 1)\r\n          counts[set]--\r\n        }\r\n        return\r\n      }\r\n      for (const set of [...isolated, ...missing]) {\r\n        counts[set]++\r\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n        yield* check_free(i + 1)\r\n        counts[set]--\r\n      }\r\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\r\n      yield* check_free(i + 1)\r\n    }\r\n    yield* check(0)\r\n  }\r\n  for (const shape of shapes) yield* check(shape)\r\n}\r\n\r\nexport type RequestFilter = StrictDict<SlotKey,\r\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"id\", ids: Set<string> }\r\n>\r\n\r\nexport type DynStat = { [key in string]: number }\r\nexport type ArtifactBuildData = {\r\n  id: string\r\n  set?: ArtifactSetKey\r\n  values: DynStat\r\n}\r\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\r\n\r\nexport type PlotData = Dict<number, Build>\r\nexport interface Build {\r\n  value: number\r\n  plot?: number\r\n  artifactIds: string[]\r\n}\r\n\r\nexport type DynMinMax = { [key in string]: MinMax }\r\nexport type MinMax = { min: number, max: number }\r\n","import { customMapFormula, forEachNodes } from \"../../../../Formula/internal\";\nimport { allOperations, OptNode } from \"../../../../Formula/optimization\";\nimport { ConstantNode } from \"../../../../Formula/type\";\nimport { prod, threshold } from \"../../../../Formula/utils\";\nimport { SlotKey } from \"../../../../Types/consts\";\nimport { assertUnreachable, objectKeyValueMap, objectMap } from \"../../../../Util/Util\";\nimport type { InterimResult, Setup, SplitWorker } from \"./BackgroundWorker\";\nimport { ArtifactBuildData, ArtifactsBySlot, computeFullArtRange, computeNodeRange, countBuilds, DynStat, filterArts, MinMax, pruneAll, RequestFilter } from \"./common\";\n\ntype Approximation = {\n  base: number,\n  /** optimization target contribution from a given artifact (id) */\n  conts: StrictDict<string, number>\n}\ntype Filter = {\n  nodes: OptNode[], arts: ArtifactsBySlot\n  /**\n   * The contribution of each artifact to the optimization target. The (over)estimated\n   * optimization target value is the sum of contributions of all artifacts in the build.\n   */\n  approxs: Approximation[], maxConts: Record<SlotKey, number>[]\n  /** How many times has this filter been splitted */\n  age: number\n  /** Total number of builds in this filter */\n  count: number\n  /** Whether or not this filter is in a valid (calculated) state */\n  calculated?: boolean\n}\nexport class BNBSplitWorker implements SplitWorker {\n  min: number[]\n  nodes: OptNode[]\n  arts: ArtifactsBySlot\n  maxBuilds: number\n\n  /**\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\n   * We amortize the calculation to 1-per-split so that the calculation\n   * overhead doesn't lead to lag.\n   */\n  filters: Filter[] = []\n  interim: InterimResult | undefined\n  firstUncalculated = 0\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, optimizationTarget, filters, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.min = [-Infinity, ...filters.map(x => x.min)]\n    this.nodes = [optimizationTarget, ...filters.map(x => x.value)]\n    this.callback = callback\n    this.maxBuilds = maxBuilds\n\n    // make sure we can approximate it\n    linearUpperBound(this.nodes, arts)\n  }\n\n  addFilter(filter: RequestFilter): void {\n    const arts = filterArts(this.arts, filter), count = countBuilds(arts)\n    if (count)\n      this.filters.push({ nodes: this.nodes, arts, maxConts: [], approxs: [], age: 0, count })\n  }\n  split(newThreshold: number, minCount: number): RequestFilter | undefined {\n    if (newThreshold > this.min[0]) {\n      this.min[0] = newThreshold\n      // All calculations become stale\n      this.firstUncalculated = 0\n      this.filters.forEach(filter => delete filter.calculated)\n    }\n    if (this.firstUncalculated < this.filters.length)\n      this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\n\n    while (this.filters.length) {\n      const filter = this.getApproxFilter(), { arts, count } = filter\n      this.reportInterim(false)\n      if (!count) continue\n\n      if (count <= minCount) {\n        this.reportInterim(true)\n        return objectMap(arts.values, arts => ({ kind: \"id\" as const, ids: new Set(arts.map(art => art.id)) }))\n      }\n      this.splitOldFilter(filter)\n    }\n    this.reportInterim(true)\n    return undefined\n  }\n\n  reportInterim(forced = false) {\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\n      this.callback(this.interim)\n      this.interim = undefined\n    }\n  }\n\n  splitOldFilter({ nodes, arts, approxs, age }: Filter) {\n    /**\n     * Split the artifacts in each slot into high/low main (index 0) contribution along 1/3 of the\n     * contribution range. If the main contribution of a slot is in range 500-2000, the the high-\n     * contibution artifact has contribution of at least 1500, and the rest are low-contribution.\n     */\n    const splitted = objectMap(arts.values, arts => {\n      const remaining = arts.map((art) => ({ art, cont: approxs[0].conts[art.id] }))\n        .sort(({ cont: c1 }, { cont: c2 }) => c2 - c1)\n      const minCont = remaining[remaining.length - 1]?.cont ?? 0\n      let contCutoff = remaining.reduce((accu, { cont }) => accu + cont, -minCont * remaining.length) / 3\n\n      const index = Math.max(1, remaining.findIndex(({ cont }) => (contCutoff -= cont - minCont) <= 0))\n      const lowArts = remaining.splice(index).map(({ art }) => art), highArts = remaining.map(({ art }) => art)\n      return {\n        high: { arts: highArts, maxConts: approxs.map(approx => maxContribution(highArts, approx)), },\n        low: { arts: lowArts, maxConts: approxs.map(approx => maxContribution(lowArts, approx)) },\n      }\n    })\n    const remaining = Object.keys(splitted), { filters } = this\n    const current: StrictDict<SlotKey, ArtifactBuildData[]> = {} as any\n    const currentCont: StrictDict<SlotKey, number[]> = {} as any\n    function partialSplit(count: number) {\n      if (!remaining.length) {\n        const maxConts = approxs.map((_, i) => objectMap(currentCont, val => val[i]))\n        const currentArts = { base: arts.base, values: { ...current } }\n        filters.push({ nodes, arts: currentArts, maxConts, approxs, age: age + 1, count })\n        return\n      }\n      const slot = remaining.pop()!, { high, low } = splitted[slot]\n      if (low.arts.length) {\n        current[slot] = low.arts\n        currentCont[slot] = low.maxConts\n        partialSplit(count * low.arts.length)\n      }\n      if (high.arts.length) {\n        current[slot] = high.arts\n        currentCont[slot] = high.maxConts\n        partialSplit(count * high.arts.length)\n      }\n      remaining.push(slot)\n    }\n    partialSplit(1)\n  }\n\n  /** *Precondition*: `this.filters` must not be empty */\n  getApproxFilter(): Filter {\n    this.calculateFilter(this.filters.length - 1)\n    if (this.firstUncalculated > this.filters.length)\n      this.firstUncalculated = this.filters.length\n    return this.filters.pop()!\n  }\n  /** Update calculate on filter at index `i` if not done so already */\n  calculateFilter(i: number): void {\n    let { nodes, arts, maxConts, approxs, age, count: oldCount, calculated } = this.filters[i]\n    if (calculated) return\n    if (age < 3 || age % 5 === 2) { // Make sure the condition includes initial filter `age === 0`\n      // Either the filter is so early that we can get a good cutoff, or the problem has\n      // gotten small enough that the old approximation becomes inaccurate\n      ({ nodes, arts } = pruneAll(nodes, this.min, arts, this.maxBuilds, {}, { pruneNodeRange: true }))\n      if (Object.values(arts.values).every(x => x.length)) {\n        approxs = approximation(nodes, arts)\n        maxConts = approxs.map(approx => objectMap(arts.values, val => maxContribution(val, approx)))\n      }\n    }\n    // Removing artifacts that doesn't meet the required opt target contributions.\n    //\n    // We could actually loop `newValues` computation if the removed artifacts have\n    // the highest contribution in one of the target node as the removal will raise\n    // the required contribution even further. However, once is generally enough.\n    const leadingConts = maxConts.map((cont, i) => Object.values(cont)\n      .reduce((accu, val) => accu + val, approxs[i].base - this.min[i]))\n    const newValues = objectMap(arts.values, (arts, slot) => {\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\n      return arts.filter(({ id }) => approxs.every(({ conts }, i) => conts[id] >= requiredConts[i]))\n    })\n    arts = { base: arts.base, values: newValues }\n    const newCount = countBuilds(arts)\n    if (newCount !== oldCount)\n      if (this.interim) this.interim.skipped += oldCount - newCount\n      else this.interim = { command: \"interim\", buildValues: undefined, tested: 0, failed: 0, skipped: oldCount - newCount }\n    this.filters[i] = { nodes, arts, maxConts, approxs, age, count: newCount, calculated: true }\n  }\n}\n\nfunction maxContribution(arts: ArtifactBuildData[], approximation: Approximation): number {\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\n}\nfunction approximation(nodes: OptNode[], arts: ArtifactsBySlot): Approximation[] {\n  return linearUpperBound(nodes, arts).map(weight => ({\n    base: dot(arts.base, weight, weight.$c),\n    conts: objectKeyValueMap(Object.values(arts.values).flat(),\n      data => [data.id, dot(data.values, weight, 0)])\n  }))\n}\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\n  return Object.entries(values).reduce((accu, [k, v]) => accu + (lin[k] ?? 0) * v, c)\n}\n\nfunction weightedSum(...entries: readonly (readonly [number, Linear])[]): Linear\nfunction weightedSum(...entries: readonly (readonly [number, DynStat])[]): DynStat\nfunction weightedSum(...entries: readonly (readonly [number, DynStat])[]): DynStat {\n  const result = {}\n  for (const [weight, entry] of entries)\n    for (const [k, v] of Object.entries(entry))\n      result[k] = (result[k] ?? 0) + weight * v\n  return result\n}\nexport type Linear = DynStat & { $c: number }\n/** Compute a linear upper bound of `nodes` */\nexport function linearUpperBound(nodes: OptNode[], arts: ArtifactsBySlot): Linear[] {\n  const cents = weightedSum([1, arts.base], ...Object.values(arts.values).map(arts =>\n    [1 / arts.length, weightedSum(...arts.map(art => [1, art.values] as const))] as const))\n  const getCent = (lin: Linear) => dot(cents, lin, lin.$c)\n\n  const minMaxes = new Map<OptNode, MinMax>()\n  forEachNodes(nodes, f => {\n    const { operation } = f\n    if (operation === \"mul\") minMaxes.set(f, { min: NaN, max: NaN })\n    switch (operation) {\n      case \"mul\": case \"min\": case \"max\": case \"threshold\": case \"res\": case \"sum_frac\":\n        f.operands.forEach(op => minMaxes.set(op, { min: NaN, max: NaN })); break\n    }\n  }, _ => _)\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], computeFullArtRange(arts))\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\n\n  function slopePoint(slope: number, x0: number, y0: number, lin: Linear): Linear {\n    return weightedSum([1, { $c: y0 - slope * x0 }], [slope, lin])\n  }\n  function interpolate(x0: number, y0: number, x1: number, y1: number, lin: Linear, upper: boolean): Linear {\n    if (Math.abs(x0 - x1) < 1e-10)\n      return { $c: upper ? Math.max(y0, y1) : Math.min(y0, y1) }\n    return slopePoint((y1 - y0) / (x1 - x0), x0, y0, lin)\n  }\n\n  const upper = \"u\", lower = \"l\", outward = \"o\"\n  type Context = typeof upper | typeof lower | typeof outward\n  return customMapFormula<Context, Linear, OptNode>(nodes, upper, (f, context, _map) => {\n    const { operation } = f\n    const map: (op: OptNode, c?: Context) => Linear = (op, c = context) => _map(op, c)\n    const oppositeContext = context === upper ? lower : upper\n\n    if (context === outward) {\n      const { min, max } = minMaxes.get(f)!\n      if (min < 0 && max > 0)\n        // TODO: We can bypass this restriction by converting `f`\n        // to `min(f, 0)` or `max(f, 0)` as appropriate\n        throw new PolyError(\"Zero-crossing\", operation)\n      return map(f, max <= 0 ? lower : upper)\n    }\n\n    switch (operation) {\n      case \"const\": return { $c: f.value }\n      case \"read\": return { $c: 0, [f.path[1]]: 1 }\n      case \"add\": return weightedSum(...f.operands.map(op => [1, map(op)] as const))\n      case \"min\": case \"max\": {\n        const op = allOperations[operation]\n        const xs = f.operands.filter(op => op.operation !== \"const\"), [xOp] = xs\n        if (xs.length !== 1) throw new PolyError(\"Multivariate\", operation)\n\n        const x = map(xOp), c = op(f.operands.filter(op => op.operation === \"const\")\n          .map(c => (c as ConstantNode<number>).value))\n        if ((operation === \"max\" && context === lower) || (operation === \"min\" && context === upper))\n          return x\n        const { min, max } = minMaxes.get(xOp)!, yMin = op([min, c]), yMax = op([max, c])\n        return interpolate(min, yMin, max, yMax, x, context === upper)\n      }\n      case \"res\": {\n        if (context !== upper) throw new PolyError(\"Unsupported direction\", operation)\n        const op = allOperations[operation]\n        const [xOp] = f.operands, { min, max } = minMaxes.get(xOp)!\n        const x = map(xOp, oppositeContext)\n        // Linear region 1 - base/2 or concave region with peak at base = 0\n        if (min < 0 && max < 1.75) return weightedSum([1, { $c: 1 }], [-0.5, x])\n        // Clamp `min` to guarantee upper bound\n        else return interpolate(min, op([min]), max, op([max]), x, context === upper)\n      }\n      case \"sum_frac\": {\n        if (context !== upper) throw new PolyError(\"Unsupported direction\", operation)\n        const [xOp, cOp] = f.operands\n        if (cOp.operation !== \"const\") throw new PolyError(\"Non-constant node\", operation)\n        const x = map(xOp), c = cOp.value, { min, max } = minMaxes.get(xOp)!\n        const loc = Math.sqrt((min + c) * (max + c))\n        if (min <= -c) throw new PolyError(\"Unsupported pattern\", operation)\n        return slopePoint(c / (c + loc) / (c + loc), loc, loc / (loc + c), x)\n      }\n      case \"threshold\": {\n        const [vOp, tOp, pOp, fOp] = f.operands\n        if (fOp.operation !== \"const\" || tOp.operation !== \"const\")\n          throw new PolyError(\"Non-constant node\", operation)\n        if (pOp.operation !== \"const\") {\n          if (fOp.value !== 0) throw new PolyError(\"Unsupported pattern\", operation)\n\n          const threshOp = threshold(vOp, tOp, 1, fOp), mulOp = prod(threshOp, pOp)\n          // Populate `minMaxes` to ensure consistency\n          const { min, max } = minMaxes.get(pOp)!\n          minMaxes.set(threshOp, { min: 0, max: 1 })\n          minMaxes.set(mulOp, { min: Math.min(min, 0), max: Math.max(max, 0) })\n          return map(mulOp)\n        }\n        const { min, max } = minMaxes.get(vOp)!\n        const thresh = tOp.value, pass = pOp.value, fail = fOp.value\n        const isFirstHalf = (pass > fail) === (context === upper)\n\n        const v = map(vOp, pass > fail ? context : oppositeContext)\n        const yThresh = isFirstHalf ? pass : fail\n        const slope = (pass - fail) / (isFirstHalf ? (thresh - min) : (max - thresh))\n        return slopePoint(slope, thresh, yThresh, v)\n      }\n      case \"mul\": {\n        const { min, max } = minMaxes.get(f)!\n        if (min < 0 && max > 0) throw new PolyError(\"Zero-crossing\", operation)\n        if ((min < 0 && context !== lower) || (max > 0 && context !== upper))\n          throw new PolyError(\"Unsupported direction\", operation)\n\n        // For x/a >= 0, sum{x/a} <= n, and k > 0, it follows that\n        //\n        //   k prod{x} <= k/n prod{a} sum{x/a}\n        //\n        // This follows from AM-GM; prod{x/a} <= (sum{x/a}/n)^n <= sum{x/a}/n\n        const operands = [...f.operands], flattenedOperands: OptNode[] = []\n        let coeff = 1\n        while (operands.length) {\n          const operand = operands.pop()!\n          if (operand.operation === \"mul\") operands.push(...operand.operands)\n          else if (operand.operation === \"const\") coeff *= operand.value;\n          else flattenedOperands.push(operand)\n        }\n        const lins = flattenedOperands.map(op => map(op, outward))\n        const ranges = flattenedOperands.map(op => minMaxes.get(op)!)\n\n        // Set `a` to the centroid of `x`, normalizing so that `sum{x/a} = n`\n        const cents = lins.map(getCent)\n        const factor = cents.reduce((accu, cent, i) => accu + (cent >= 0 ? ranges[i].max : ranges[i].min) / cent, 0)\n        const prod = cents.reduce((a, b) => a * factor * b / lins.length, coeff / factor)\n        return weightedSum(...lins.map((op, i) => [prod / cents[i], op] as const))\n      }\n\n      default: assertUnreachable(operation)\n    }\n  })\n}\nclass PolyError extends Error {\n  constructor(cause: string, operation: string) {\n    super(`Found ${cause} in ${operation} node when generating polynomial upper bound`)\n  }\n}\n","import { optimize, OptNode, precompute } from '../../../../Formula/optimization';\nimport type { InterimResult, Setup } from './BackgroundWorker';\nimport { ArtifactBuildData, ArtifactsBySlot, Build, countBuilds, filterArts, mergePlot, PlotData, pruneAll, RequestFilter } from './common';\n\nexport class ComputeWorker {\n  builds: Build[] = []\n  buildValues: number[] | undefined = undefined\n  plotData: PlotData | undefined\n  threshold = -Infinity\n  maxBuilds: number\n  min: number[]\n\n  arts: ArtifactsBySlot\n  nodes: OptNode[]\n\n  callback: (interim: InterimResult) => void\n\n  constructor({ arts, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\n    this.arts = arts\n    this.min = filters.map(x => x.min)\n    this.maxBuilds = maxBuilds\n    this.callback = callback\n    this.nodes = filters.map(x => x.value)\n    this.nodes.push(optimizationTarget)\n    if (plotBase) {\n      this.plotData = {}\n      this.nodes.push(plotBase)\n    }\n    this.nodes = optimize(this.nodes, {}, _ => false)\n  }\n\n  compute(newThreshold: number, filter: RequestFilter) {\n    if (this.threshold > newThreshold) this.threshold = newThreshold\n    const { min, interimReport } = this, self = this // `this` in nested functions means different things\n    let preArts = filterArts(this.arts, filter)\n    const totalCount = countBuilds(preArts), oldMaxBuildCount = this.builds.length\n\n    let nodes = this.nodes;\n    ({ nodes, arts: preArts } = pruneAll(nodes, min, preArts, this.maxBuilds, {}, {\n      pruneArtRange: true, pruneNodeRange: true,\n    }))\n    const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\n    const compute = precompute(nodes, preArts.base, f => f.path[1], arts.length)\n\n    const buffer = Array<ArtifactBuildData>(arts.length)\n    const count = { tested: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\n\n    function permute(i: number) {\n      if (i < 0) {\n        const result = compute(buffer)\n        if (min.every((m, i) => (m <= result[i]))) {\n          const value = result[min.length], { builds, plotData } = self\n          let build: Build | undefined\n          if (value >= self.threshold) {\n            build = { value, artifactIds: buffer.map(x => x.id).filter(id => id) }\n            builds.push(build)\n          }\n          if (plotData) {\n            const x = result[min.length + 1]\n            if (!plotData[x] || plotData[x]!.value < value) {\n              if (!build) build = { value, artifactIds: buffer.map(x => x.id).filter(id => id) }\n              build.plot = x\n              plotData[x] = build\n            }\n          }\n        }\n        else count.failed += 1\n        return\n      }\n      arts[i].forEach(art => {\n        buffer[i] = art\n        permute(i - 1)\n      })\n      if (i === 0) {\n        count.tested += arts[0].length\n        if (count.tested > 1 << 16)\n          interimReport(count)\n      }\n    }\n\n    permute(arts.length - 1)\n    interimReport(count, this.builds.length > oldMaxBuildCount)\n  }\n\n  refresh(force: boolean): void {\n    const { maxBuilds } = this\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\n      this.plotData = mergePlot([this.plotData!])\n\n    if (this.builds.length >= 1000 || force) {\n      this.builds = this.builds\n        .sort((a, b) => b.value - a.value)\n        .slice(0, maxBuilds)\n      this.buildValues = this.builds.map(x => x.value)\n      this.threshold = Math.max(this.threshold, this.buildValues[maxBuilds - 1] ?? -Infinity)\n    }\n  }\n  interimReport = (count: { tested: number, failed: number, skipped: number }, forced = false) => {\n    this.refresh(forced)\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\n    this.buildValues = undefined\n    count.tested = 0\n    count.failed = 0\n    count.skipped = 0\n  }\n}\n","import { allSlotKeys } from '../../../../Types/consts';\r\nimport type { InterimResult, Setup, SplitWorker } from './BackgroundWorker';\r\nimport { ArtifactsBySlot, countBuilds, filterArts, RequestFilter } from './common';\r\n\r\nexport class DefaultSplitWorker implements SplitWorker {\r\n  arts: ArtifactsBySlot\r\n  filters: RequestFilter[] = []\r\n\r\n  constructor({ arts }: Setup, _callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n  }\r\n  addFilter(filter: RequestFilter) {\r\n    this.filters.push(filter)\r\n  }\r\n  split(_newThreshold: number, minCount: number) {\r\n    while (this.filters.length) {\r\n      const filter = this.filters.pop()!, count = countBuilds(filterArts(this.arts, filter))\r\n      if (count <= minCount) return filter\r\n      splitBySetOrID(this.arts, filter, minCount).forEach(filter => this.addFilter(filter))\r\n    }\r\n  }\r\n}\r\n\r\nfunction splitBySetOrID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, sets: new Set(arts.values[slot].map(x => x.set)) }))\r\n    .filter(({ sets }) => sets.size > 1)\r\n  if (!candidates.length)\r\n    return splitByID(arts, filter, limit)\r\n  const { sets, slot } = candidates.reduce((a, b) => a.sets.size < b.sets.size ? a : b)\r\n  return [...sets].map(set => ({ ...filter, [slot]: { kind: \"required\", sets: new Set([set]) } }))\r\n}\r\nfunction splitByID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n  const count = countBuilds(arts)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, length: arts.values[slot].length }))\r\n    .filter(x => x.length > 1)\r\n  const { slot, length } = candidates.reduce((a, b) => a.length < b.length ? a : b)\r\n\r\n  const numChunks = Math.ceil(count / limit)\r\n  const boundedNumChunks = Math.min(numChunks, length)\r\n  const chunk = Array(boundedNumChunks).fill(0).map(_ => new Set<string>())\r\n  arts.values[slot].forEach(({ id }, i) => chunk[i % boundedNumChunks].add(id))\r\n  return chunk.map(ids => ({ ...filter, [slot]: { kind: \"id\", ids } }))\r\n}\r\n","import { ArtSetExclusion } from '../../../../Database/DataManagers/BuildSettingData'\r\nimport { OptNode } from '../../../../Formula/optimization'\r\nimport { assertUnreachable } from '../../../../Util/Util'\r\nimport { BNBSplitWorker } from \"./BNBSplitWorker\"\r\nimport { ArtifactsBySlot, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\r\nimport { ComputeWorker } from \"./ComputeWorker\"\r\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\r\n\r\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\r\n\r\nonmessage = ({ data }: { data: WorkerCommand }) => {\r\n  const { command } = data\r\n  let result: WorkerResult\r\n  switch (command) {\r\n    case \"setup\": {\r\n      id = data.id\r\n      const splitID = `split${id}`, computeID = `compute${id}`\r\n      try {\r\n        splitWorker = new BNBSplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\r\n      } catch {\r\n        splitWorker = new DefaultSplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\r\n      }\r\n      computeWorker = new ComputeWorker(data, interim => postMessage({ id, source: computeID, ...interim }))\r\n      result = { command: \"iterate\" }\r\n      break\r\n    }\r\n    case \"split\": {\r\n      if (data.filter) splitWorker.addFilter(data.filter)\r\n      const filter = splitWorker.split(data.threshold, data.minCount)\r\n      result = { command: \"split\", filter }\r\n      break\r\n    }\r\n    case \"iterate\": {\r\n      const { threshold, filter } = data\r\n      computeWorker.compute(threshold, filter)\r\n      result = { command: \"iterate\" }\r\n      break\r\n    }\r\n    case \"finalize\": {\r\n      computeWorker.refresh(true)\r\n      const { builds, plotData } = computeWorker\r\n      result = { command: \"finalize\", builds, plotData }\r\n      break\r\n    }\r\n    case \"count\": {\r\n      const { exclusion } = data, arts = computeWorker.arts\r\n      const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\r\n      const counts = data.arts.map(_ => 0)\r\n      for (const perm of setPerm)\r\n        data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\r\n      result = { command: \"count\", counts }\r\n      break\r\n    }\r\n    default: assertUnreachable(command)\r\n  }\r\n  postMessage({ id, ...result })\r\n}\r\n\r\nexport interface SplitWorker {\r\n  addFilter(filter: RequestFilter): void\r\n  split(newThreshold: number, minCount: number): RequestFilter | undefined\r\n}\r\n\r\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Count\r\nexport type WorkerResult = SourcedInterimResult | SplitResult | IterateResult | FinalizeResult | CountResult\r\n\r\nexport interface Setup {\r\n  command: \"setup\"\r\n\r\n  id: number\r\n  arts: ArtifactsBySlot\r\n\r\n  optimizationTarget: OptNode\r\n  filters: { value: OptNode, min: number }[]\r\n  plotBase: OptNode | undefined,\r\n  maxBuilds: number\r\n}\r\nexport interface Split {\r\n  command: \"split\"\r\n  threshold: number\r\n  minCount: number\r\n  filter?: RequestFilter\r\n}\r\nexport interface Iterate {\r\n  command: \"iterate\"\r\n  threshold: number\r\n  filter: RequestFilter\r\n}\r\n\r\nexport interface Finalize {\r\n  command: \"finalize\"\r\n}\r\nexport interface Count {\r\n  command: \"count\"\r\n  arts: ArtifactsBySlot[]\r\n  exclusion: ArtSetExclusion\r\n}\r\nexport interface SplitResult {\r\n  command: \"split\"\r\n  filter: RequestFilter | undefined\r\n}\r\nexport interface IterateResult {\r\n  command: \"iterate\"\r\n}\r\nexport interface FinalizeResult {\r\n  command: \"finalize\"\r\n  builds: Build[]\r\n  plotData?: PlotData\r\n}\r\nexport interface CountResult {\r\n  command: \"count\"\r\n  counts: number[]\r\n}\r\nexport interface InterimResult {\r\n  command: \"interim\"\r\n  buildValues: number[] | undefined\r\n  /** The number of builds since last report, including failed builds */\r\n  tested: number\r\n  /** The number of builds that does not meet the min-filter requirement since last report */\r\n  failed: number\r\n  skipped: number\r\n}\r\nexport interface SourcedInterimResult extends InterimResult {\r\n  /** the source of the message, must be unique for each source of `buildValues` */\r\n  source: string\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = () => {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [531], () => (__webpack_require__(12337)))\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + \"161cc23ea5600aac\" + \".js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t337: 1\n};\n\n// importScripts chunk loading\nvar installChunk = (data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = (chunkId, promises) => {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunk\"] = self[\"webpackChunk\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["deferred","next","objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectKeyValueMap","items","t","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","assign","unit","intoOps","values","intoV","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","customMapFormula","context","contextMapping","internalMap","current","mapping","old","newFormula","b","undefined","length","every","allCommutativeMonoidOperations","min","x","Math","max","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","f","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","_result$get","wrap","common","counts","factored","count","fill","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","_nextCounts$get","commonCount","candidates","candidate","candidateCounts","candidateCount","_counts$get","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","_formulaOperands$","fold","c","foldStr","numericOperands","formulaOperands","folded","numericValue","isFinite","index","_formula$table","selected","table","first","find","op","_smallest2","smallest","operand","_smallest","v1","v2","match","unmatch","list","path","accu","reset","nextMap","nextContext","nonTravelerCharacterKeys","travelerKeys","allWeaponSwordKeys","allWeaponClaymoreKeys","allWeaponPolearmKeys","allWeaponBowKeys","allWeaponCatalystKeys","allSlotKeys","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","dynKeys","_","nonConst","base","size","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","_affineMap$get","slot","id","offsets","key","baseValue","_exclusion$rainbow","progress","allowRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","otherBetterEqual","_other$values$k","_art$values$k","otherMaybeBetter","_other$values$k2","_art$values$k2","otherBetter","canSwitch","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","_minimum$i","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","reads","_reads$f$path$","computeMinMax","sum","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","exclusionToAllowed","artSetPerm","_artSets","artSets","allowedRainbows","shapes","indexOfShape","shape","replacing","populateShapes","rainbows","required","_required$get","slice","remaining","noFilter","allowedCounts","used","groupped","sort","usableRainbows","check_free","isolated","missing","rejected","allowedSet","requiredRainbows","_range$find","l","BNBSplitWorker","constructor","optimizationTarget","maxBuilds","callback","interim","firstUncalculated","this","linearUpperBound","addFilter","maxConts","approxs","age","split","newThreshold","minCount","calculated","calculateFilter","getApproxFilter","reportInterim","splitOldFilter","skipped","splitted","_remaining$cont","_remaining","cont","conts","c1","c2","minCont","contCutoff","findIndex","lowArts","splice","highArts","high","approx","maxContribution","low","currentCont","partialSplit","val","currentArts","pop","oldCount","weight","dot","$c","flat","approximation","leadingConts","newValues","requiredConts","lc","newCount","command","buildValues","tested","failed","lin","_lin$k","weightedSum","entry","_result$k","cents","getCent","nodeRanges","computeFullArtRange","minMax","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","lower","_map","oppositeContext","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","ge","le","mulOp","prod","thresh","isFirstHalf","flattenedOperands","coeff","lins","factor","cent","cause","super","ComputeWorker","plotBase","builds","plotData","interimReport","refresh","opts","optimize","compute","self","preArts","totalCount","oldMaxBuildCount","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","m","build","artifactIds","plot","force","_this$plotData","_this$buildValues","plots","scale","round","mergePlot","DefaultSplitWorker","_callback","_newThreshold","splitBySetOrID","_arts","limit","numChunks","ceil","boundedNumChunks","chunk","splitByID","splitWorker","computeWorker","onmessage","splitID","computeID","postMessage","source","_unused","setPerm","filter_loop","available","s","filterFeasiblePerm","perm","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","chunkIds","priority","notFulfilled","fulfilled","r","e","chunkId","Promise","all","promises","u","miniCssF","g","globalThis","window","o","prop","prototype","hasOwnProperty","call","scriptUrl","importScripts","location","document","currentScript","src","scripts","getElementsByTagName","replace","p","installedChunks","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}